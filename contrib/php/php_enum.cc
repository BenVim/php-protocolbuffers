#include "php_generator.h"
#include "php_enum.h"
#include "php_helpers.h"
#include "strutil.h"

namespace google {
namespace protobuf {
namespace compiler {
namespace php {

EnumGenerator::EnumGenerator(const EnumDescriptor* descriptor, GeneratorContext* context)
    : descriptor_(descriptor),
      context_(context)
{
    enclose_namespace_ = false;
}

EnumGenerator::~EnumGenerator()
{
}

string EnumGenerator::ClassName()
{
    vector<string> result;

    SplitStringUsing(descriptor_->full_name(), ".", &result);

    return result.back();
}

string EnumGenerator::NameSpace()
{
    vector<string> result;
    string output;

    SplitStringUsing(descriptor_->full_name(), ".", &result);
    result.pop_back();

    JoinStrings(result,
                 "\\",
                 &output);

    return output;
}

void EnumGenerator::PrintUseNameSpaceIfNeeded(io::Printer* printer)
{
    if (enclose_namespace_) {
        printer->Print(
            "namespace `namespace`\n{\n",
            "namespace",
            NameSpace()
        );
    } else {
        printer->Print(
            "namespace `namespace`;\n\n",
            "namespace",
            NameSpace()
        );
    }

    printer->Print("\n");
}

string EnumGenerator::FileName()
{
    string name = descriptor_->full_name();
    replace(name.begin(), name.end(), '.', '/');
    name.append(".php");

    return name;
}


void EnumGenerator::Generate(io::Printer* printer)
{
    printer->Print(
        "<?php\n"
    );

    PrintUseNameSpaceIfNeeded(printer);
    if (enclose_namespace_) {
        printer->Indent();
    }

    printer->Print(
        "/**\n"
        " * Generated by the protocol buffer compiler.  DO NOT EDIT!\n"
        " * source: `filename`\n"
        " */\n"
        ,
        "filename", descriptor_->file()->name());

    printer->Print(
        "class `class_name`\n"
        "{\n"
        ,
        "class_name", ClassName()
    );

    printer->Indent();

    for (int j = 0; j < descriptor_->value_count(); ++j) {
        const EnumValueDescriptor &value ( *descriptor_->value(j) );

        printer->Print(
                "const `name` = `number`;\n",
                "name",   UpperString(value.name()),
                "number", SimpleItoa(value.number())
                 );
    }

    printer->Outdent();
    printer->Print(
        "}\n\n"
    );

    if (enclose_namespace_) {
        printer->Outdent();
        printer->Print(
            "}\n"
        );
    }

}

}  // namespace php
}  // namespace compiler
}  // namespace protobuf
}  // namespace google
