// Copyright 2013 Shuhei Tanuma.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include <google/protobuf/compiler/php/php_generator.h>
#include <google/protobuf/compiler/php/php_enum.h>
#include <google/protobuf/compiler/php/php_helpers.h>

namespace google {
namespace protobuf {
namespace compiler {
namespace php {

EnumGenerator::EnumGenerator(const EnumDescriptor* descriptor,
  GeneratorContext* context)
  : descriptor_(descriptor),
    context_(context) {
  enclose_namespace_ = false;
}

EnumGenerator::~EnumGenerator() {
}

string EnumGenerator::ClassName() {
  vector<string> result;

  SplitStringUsing(descriptor_->full_name(), ".", &result);

  return result.back();
}

string EnumGenerator::NameSpace() {
  vector<string> result;
  string output;

  SplitStringUsing(descriptor_->full_name(), ".", &result);
  result.pop_back();

  JoinStrings(result, "\\", &output);

  return output;
}

void EnumGenerator::PrintUseNameSpaceIfNeeded(io::Printer* printer) {
  if (enclose_namespace_) {
    printer->Print("namespace `namespace`\n{\n",
      "namespace",
      NameSpace());
  } else {
    printer->Print("namespace `namespace`;\n\n",
      "namespace",
      NameSpace());
  }

  printer->Print("\n");
}

string EnumGenerator::FileName() {
  string name = descriptor_->full_name();
  replace(name.begin(), name.end(), '.', '/');
  name.append(".php");

  return name;
}

string EnumGenerator::GetEnumValueAsString(const EnumValueDescriptor &value) {
  return value.name();
}

void EnumGenerator::Generate(io::Printer* printer) {
  printer->Print("<?php\n");

  PrintUseNameSpaceIfNeeded(printer);
  if (enclose_namespace_) {
    printer->Indent();
  }

  printer->Print(
    "/**\n"
    " * Generated by the protocol buffer compiler.  DO NOT EDIT!\n"
    " * source: `filename`\n"
    " */\n"
    ,
    "filename", descriptor_->file()->name());

  printer->Print(
    "class `class_name`\n"
    "{\n"
    ,
    "class_name", ClassName());

  printer->Indent();

  for (int j = 0; j < descriptor_->value_count(); ++j) {
    const EnumValueDescriptor &value(*descriptor_->value(j));

    printer->Print(
    "const `name` = `number`;\n",
    "name",   EnumGenerator::GetEnumValueAsString(value),
    "number", SimpleItoa(value.number()));
  }

  printer->Outdent();
  printer->Print("}\n\n");

  if (enclose_namespace_) {
    printer->Outdent();
    printer->Print("}\n");
  }
}

}  // namespace php
}  // namespace compiler
}  // namespace protobuf
}  // namespace google
